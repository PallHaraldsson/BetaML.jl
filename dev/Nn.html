<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nn · Bmlt.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Bmlt.jl Documentation</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Index</a></li><li><a class="tocitem" href="Perceptron.html">Perceptron</a></li><li class="is-active"><a class="tocitem" href="Nn.html">Nn</a><ul class="internal"><li><a class="tocitem" href="#Module-Index-1"><span>Module Index</span></a></li><li><a class="tocitem" href="#Detailed-API-1"><span>Detailed API</span></a></li></ul></li><li><a class="tocitem" href="Clustering.html">Clustering</a></li><li><a class="tocitem" href="Utils.html">Utils</a></li><li><a class="tocitem" href="Notebooks.html">Notebooks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Nn.html">Nn</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Nn.html">Nn</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/Bmlt.jl/blob/master/docs/src/Nn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Bmlt.Nn-Module-1"><a class="docs-heading-anchor" href="#The-Bmlt.Nn-Module-1">The Bmlt.Nn Module</a><a class="docs-heading-anchor-permalink" href="#The-Bmlt.Nn-Module-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn" href="#Bmlt.Nn"><code>Bmlt.Nn</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Bmlt.Nn module</code></pre><p>Implement the functionality required to define an artificial Neural Network, train it with data, forecast data and assess its performances.</p><p>Common type of layers and optimisation algorithms are already provided, but you can define your own ones subclassing respectively the <code>Layer</code> and <code>OptimisationAlgorithm</code> abstract types.</p><p>The module provide the following type or functions. Use <code>?[type or function]</code> to access their full signature and detailed documentation:</p><p><strong>Model definition:</strong></p><ul><li><code>DenseLayer</code>: Classical feed-forward layer with user-defined activation function</li><li><code>DenseNoBiasLayer</code>: Classical layer without the bias parameter</li><li><code>VectorFunctionLayer</code>: Parameterless layer whose activation function run over the ensable of its nodes rather than on each one individually</li><li><code>buildNetwork</code>: Build the chained network and define a cost function</li><li><code>getParams(nn)</code>: Retrieve current weigthts</li><li><code>getGradient(nn)</code>: Retrieve the current gradient of the weights</li><li><code>setParams!(nn)</code>: Update the weigths of the network</li><li><code>show(nn)</code>: Print a representation of the Neural Network</li></ul><p>Each layer can use a default activation function or you can specify your own. The derivative of the activation function can be optionally be provided, in such case training will be quicker, altought this difference tends to vanish with bigger datasets. You can alternativly implement your own layers defining a new type as subtype of the abstract type <code>Layer</code>. Each user-implemented layer must define the following methods:</p><ul><li>A suitable constructor</li><li><code>forward(layer,x)</code></li><li><code>backward(layer,x,nextGradient)</code></li><li><code>getParams(layer)</code></li><li><code>getGradient(layer,x,nextGradient)</code></li><li><code>setParams!(layer,w)</code></li><li><code>size(layer)</code></li></ul><p><strong>Model training:</strong></p><ul><li><code>trainingInfo(nn)</code>: Default callback function during training</li><li><code>train!(nn)</code>:  Training function</li><li><code>singleUpdate(θ,▽;optAlg)</code>: The parameter update made by the specific optimisation algorithm</li><li><code>SGD</code>: The default optimisation algorithm</li></ul><p>To define your own optimisation algorithm define a subtype of <code>OptimisationAlgorithm</code> and implement the function <code>singleUpdate(θ,▽;optAlg)</code> specific for it. You can use <code>gradSum</code>, <code>gradSub</code>, <code>gradDiv</code> and <code>gradMul</code> functions to operate on the gradient structure at once.</p><p><strong>Model predictions and assessment:</strong></p><ul><li><code>predict(nn)</code>: Return the output given the data</li><li><code>loss(nn)</code>: Compute avg. network loss on a test set</li><li><code>Utils.accuracy(nn)</code>: Categorical output accuracy</li></ul><p>All high-level functions (except the low-level ones) expect x and y as (nRecords × nDimensions) matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L17-L65">source</a></section></article><h2 id="Module-Index-1"><a class="docs-heading-anchor" href="#Module-Index-1">Module Index</a><a class="docs-heading-anchor-permalink" href="#Module-Index-1" title="Permalink"></a></h2><ul><li><a href="Nn.html#Bmlt.Nn.DenseLayer"><code>Bmlt.Nn.DenseLayer</code></a></li><li><a href="Nn.html#Bmlt.Nn.DenseNoBiasLayer"><code>Bmlt.Nn.DenseNoBiasLayer</code></a></li><li><a href="Nn.html#Bmlt.Nn.NN"><code>Bmlt.Nn.NN</code></a></li><li><a href="Nn.html#Bmlt.Nn.OptimisationAlgorithm"><code>Bmlt.Nn.OptimisationAlgorithm</code></a></li><li><a href="Nn.html#Bmlt.Nn.SGD"><code>Bmlt.Nn.SGD</code></a></li><li><a href="Nn.html#Bmlt.Nn.VectorFunctionLayer"><code>Bmlt.Nn.VectorFunctionLayer</code></a></li><li><a href="Nn.html#Bmlt.Nn.backward-Tuple{Layer,Any,Any}"><code>Bmlt.Nn.backward</code></a></li><li><a href="Nn.html#Bmlt.Nn.buildNetwork-Tuple{Any,Any}"><code>Bmlt.Nn.buildNetwork</code></a></li><li><a href="Nn.html#Bmlt.Nn.forward-Tuple{Layer,Any}"><code>Bmlt.Nn.forward</code></a></li><li><a href="Nn.html#Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any,AbstractArray{T,2},AbstractArray{T2,2}}} where T2&lt;:Number where T&lt;:Number"><code>Bmlt.Nn.getGradient</code></a></li><li><a href="Nn.html#Bmlt.Nn.getGradient-Tuple{Layer,Any,Any}"><code>Bmlt.Nn.getGradient</code></a></li><li><a href="Nn.html#Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN,Union{AbstractArray{T,1}, T},Union{AbstractArray{T2,1}, T2}}} where T2&lt;:Number where T&lt;:Number"><code>Bmlt.Nn.getGradient</code></a></li><li><a href="Nn.html#Bmlt.Nn.getParams-Tuple{NN}"><code>Bmlt.Nn.getParams</code></a></li><li><a href="Nn.html#Bmlt.Nn.getParams-Tuple{Layer}"><code>Bmlt.Nn.getParams</code></a></li><li><a href="Nn.html#Bmlt.Nn.loss-Tuple{NN,Any,Any}"><code>Bmlt.Nn.loss</code></a></li><li><a href="Nn.html#Bmlt.Nn.setParams!-Tuple{Layer,Any}"><code>Bmlt.Nn.setParams!</code></a></li><li><a href="Nn.html#Bmlt.Nn.setParams!-Tuple{NN,Any}"><code>Bmlt.Nn.setParams!</code></a></li><li><a href="Nn.html#Bmlt.Nn.show-Tuple{NN}"><code>Bmlt.Nn.show</code></a></li><li><a href="Nn.html#Bmlt.Nn.singleUpdate-Tuple{Any,Any}"><code>Bmlt.Nn.singleUpdate</code></a></li><li><a href="Nn.html#Bmlt.Nn.train!-Tuple{NN,Any,Any}"><code>Bmlt.Nn.train!</code></a></li><li><a href="Nn.html#Bmlt.Nn.trainingInfo-Tuple{Any,Any,Any}"><code>Bmlt.Nn.trainingInfo</code></a></li></ul><h2 id="Detailed-API-1"><a class="docs-heading-anchor" href="#Detailed-API-1">Detailed API</a><a class="docs-heading-anchor-permalink" href="#Detailed-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.DenseLayer" href="#Bmlt.Nn.DenseLayer"><code>Bmlt.Nn.DenseLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseLayer</p><p>Representation of a layer in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>wb</code>: Biases (n)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn_default_layers.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.DenseNoBiasLayer" href="#Bmlt.Nn.DenseNoBiasLayer"><code>Bmlt.Nn.DenseNoBiasLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DenseNoBiasLayer</p><p>Representation of a layer without bias in the network</p><p><strong>Fields:</strong></p><ul><li><code>w</code>:  Weigths matrix with respect to the input from previous layer or data (n x n pr. layer)</li><li><code>f</code>:  Activation function</li><li><code>df</code>: Derivative of the activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn_default_layers.jl#L98-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.NN" href="#Bmlt.Nn.NN"><code>Bmlt.Nn.NN</code></a> — <span class="docstring-category">Type</span></header><section><div><p>NN</p><p>Representation of a Neural Network</p><p><strong>Fields:</strong></p><ul><li><code>layers</code>:  Array of layers objects</li><li><code>cf</code>:      Cost function</li><li><code>dcf</code>:     Derivative of the cost function</li><li><code>trained</code>: Control flag for trained networks</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L230-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.SGD" href="#Bmlt.Nn.SGD"><code>Bmlt.Nn.SGD</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SGD</p><p>Stochastic Gradient Descent algorithm (default)</p><p><strong>Fields:</strong></p><ul><li><code>η</code>: Learning rate, as a function of the current epoch [def: t -&gt; 1/(1+t)]</li><li><code>λ</code>: Multiplicative constant to the learning rate [def: 2]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn_default_optalgs.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.VectorFunctionLayer" href="#Bmlt.Nn.VectorFunctionLayer"><code>Bmlt.Nn.VectorFunctionLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>VectorFunctionLayer</p><p>Representation of a (weightless) VectorFunction layer in the network. Vector function layer expects a vector activation function, i.e. a function taking the whole output of the previous layer in input rather than working on a single node as &quot;normal&quot; activation functions. Useful for example for the SoftMax function.</p><p><strong>Fields:</strong></p><ul><li><code>nₗ</code>: Number of nodes of the previous layer</li><li><code>n</code>:  Number of nodes in output</li><li><code>f</code>:  Activation function (vector)</li><li><code>df</code>: Derivative of the (vector) activation function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn_default_layers.jl#L176-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{Layer}" href="#Base.size-Tuple{Layer}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(layer)</code></pre><p>SGet the dimensions of the layers in terms of (dimensions in input , dimensions in output)</p><p><strong>Notes:</strong></p><ul><li>You need to use <code>import Base.size</code> before defining this function for your layer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L215-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.backward-Tuple{Layer,Any,Any}" href="#Bmlt.Nn.backward-Tuple{Layer,Any,Any}"><code>Bmlt.Nn.backward</code></a> — <span class="docstring-category">Method</span></header><section><div><p>backward(layer,x,nextGradient)</p><p>Compute backpropagation for this layer</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>nextGradient</code>: Derivative of the overaall loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer inputs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L148-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.buildNetwork-Tuple{Any,Any}" href="#Bmlt.Nn.buildNetwork-Tuple{Any,Any}"><code>Bmlt.Nn.buildNetwork</code></a> — <span class="docstring-category">Method</span></header><section><div><p>buildNetwork</p><p>Instantiate a new Feedforward Neural Network</p><p>Parameters:</p><ul><li><code>layers</code>:  Array of layers objects</li><li><code>cf</code>:      Cost function</li><li><code>dcf</code>:     Derivative of the cost function</li></ul><p><strong>Notes:</strong></p><ul><li>Even if the network ends with a single output note, the cost function and its derivative should always expect y and ŷ as column vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L249-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.forward-Tuple{Layer,Any}" href="#Bmlt.Nn.forward-Tuple{Layer,Any}"><code>Bmlt.Nn.forward</code></a> — <span class="docstring-category">Method</span></header><section><div><p>forward(layer,x)</p><p>Predict the output of the layer given the input</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li><li><code>x</code>:      Input to the layer</li></ul><p><strong>Return:</strong></p><ul><li>An Array{T,1} of the prediction (even for a scalar)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L132-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.getGradient-Tuple{Layer,Any,Any}" href="#Bmlt.Nn.getGradient-Tuple{Layer,Any,Any}"><code>Bmlt.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(layer,x,nextGradient)</p><p>Compute backpropagation for this layer</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:        Worker layer</li><li><code>x</code>:            Input to the layer</li><li><code>nextGradient</code>: Derivative of the overaall loss with respect to the input of the next layer (output of this layer)</li></ul><p><strong>Return:</strong></p><ul><li>The evaluated gradient of the loss with respect to this layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>getParams()</code> and <code>setParams()</code> functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L181-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any,AbstractArray{T,2},AbstractArray{T2,2}}} where T2&lt;:Number where T&lt;:Number" href="#Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{Any,AbstractArray{T,2},AbstractArray{T2,2}}} where T2&lt;:Number where T&lt;:Number"><code>Bmlt.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(nn,xbatch,ybatch)</p><p>Retrieve the current gradient of the weigthts (i.e. derivative of the cost with respect to the weigths)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>:      Worker network</li><li><code>xbatch</code>:  Input to the network (n,d)</li><li><code>ybatch</code>:  Label input (n,d)</li></ul><p>#Notes:</p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L398-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN,Union{AbstractArray{T,1}, T},Union{AbstractArray{T2,1}, T2}}} where T2&lt;:Number where T&lt;:Number" href="#Bmlt.Nn.getGradient-Union{Tuple{T2}, Tuple{T}, Tuple{NN,Union{AbstractArray{T,1}, T},Union{AbstractArray{T2,1}, T2}}} where T2&lt;:Number where T&lt;:Number"><code>Bmlt.Nn.getGradient</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getGradient(nn,x,y)</p><p>Retrieve the current gradient of the weigthts (i.e. derivative of the cost with respect to the weigths)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:   Input to the network (d,1)</li><li><code>y</code>:   Label input (d,1)</li></ul><p>#Notes:</p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L346-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.getParams-Tuple{Layer}" href="#Bmlt.Nn.getParams-Tuple{Layer}"><code>Bmlt.Nn.getParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getParams(layer)</p><p>Get the layers current value of its trainable parameters</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>:  Worker layer</li></ul><p><strong>Return:</strong></p><ul><li>The current value of the layer&#39;s trainable parameters as tuple of matrices. It is up to you to decide how to organise this tuple, as long you are consistent with the <code>getGradient()</code> and <code>setParams()</code> functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L166-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.getParams-Tuple{NN}" href="#Bmlt.Nn.getParams-Tuple{NN}"><code>Bmlt.Nn.getParams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getParams(nn)</p><p>Retrieve current weigthts</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li></ul><p><strong>Notes:</strong></p><ul><li>The output is a vector of tuples of each layer&#39;s input weigths and bias weigths</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L326-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.loss-Tuple{NN,Any,Any}" href="#Bmlt.Nn.loss-Tuple{NN,Any,Any}"><code>Bmlt.Nn.loss</code></a> — <span class="docstring-category">Method</span></header><section><div><p>loss(fnn,x,y)</p><p>Compute avg. network loss on a test set (or a single (1 × d) data point)</p><p><strong>Parameters:</strong></p><ul><li><code>fnn</code>: Worker network</li><li><code>x</code>:   Input to the network (n) or (n x d)</li><li><code>y</code>:   Label input (n) or (n x d)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L303-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.setParams!-Tuple{Layer,Any}" href="#Bmlt.Nn.setParams!-Tuple{Layer,Any}"><code>Bmlt.Nn.setParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> setParams!(layer,w)</code></pre><p>Set the trainable parameters of the layer with the given values</p><p><strong>Parameters:</strong></p><ul><li><code>layer</code>: Worker layer</li><li><code>w</code>:   The new parameters to set (tuple)</li></ul><p><strong>Notes:</strong></p><ul><li>The format of the tuple with the parameters must be consistent with those of the <code>getParams()</code> and <code>getGradient()</code> functions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.setParams!-Tuple{NN,Any}" href="#Bmlt.Nn.setParams!-Tuple{NN,Any}"><code>Bmlt.Nn.setParams!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>setParams!(nn,w)</p><p>Update weigths of the network</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>w</code>:  The new weights to set</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L421-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.show-Tuple{NN}" href="#Bmlt.Nn.show-Tuple{NN}"><code>Bmlt.Nn.show</code></a> — <span class="docstring-category">Method</span></header><section><div><p>show(nn)</p><p>Print a representation of the Neural Network (layers, dimensions..)</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L439-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.singleUpdate-Tuple{Any,Any}" href="#Bmlt.Nn.singleUpdate-Tuple{Any,Any}"><code>Bmlt.Nn.singleUpdate</code></a> — <span class="docstring-category">Method</span></header><section><div><p>singleUpdate(θ,▽;nEpoch,nBatch,batchSize,xbatch,ybatch,optAlg)</p><p>Perform the parameters update based on the average batch gradient.</p><p><strong>Parameters:</strong></p><ul><li><code>θ</code>:         Current parameters</li><li><code>▽</code>:         Average gradient of the bbatch</li><li><code>nEpoch</code>:    Numer of epochs</li><li><code>nBatch</code>:    Number of batches</li><li><code>batchSize</code>: Size of each batch</li><li><code>xbatch</code>:    Data associated to the current batch</li><li><code>ybatch</code>:    Labels associated to the current batch</li><li><code>optAlg</code>:    The Optimisation algorithm to use for the update</li></ul><p><strong>Notes:</strong></p><ul><li>This function is overridden so that each optimisation algorithm implement their</li></ul><p>own version</p><ul><li>Most parameters are not used by any optimisation algorithm. They are provided</li></ul><p>to support the largest possible class of optimisation algorithms</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L606-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.train!-Tuple{NN,Any,Any}" href="#Bmlt.Nn.train!-Tuple{NN,Any,Any}"><code>Bmlt.Nn.train!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>train!(nn,x,y;epochs,batchSize,sequential,optAlg,verbosity,cb)</p><p>Train a neural network with the given x,y data</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>:         Worker network</li><li><code>x</code>:          Training input to the network (records x dimensions)</li><li><code>y</code>:          Label input (records x dimensions)</li><li><code>epochs</code>:     Number of passages over the training set [def: <code>100</code>]</li><li><code>batchSize</code>:  Size of each individual batch [def: <code>min(size(x,1),32)</code>]</li><li><code>sequential</code>: Wether to run all data sequentially instead of random [def: <code>false</code>]</li><li><code>optAlg</code>:     The optimisation algorithm to update the gradient at each batch [def: <code>SGD</code>]</li><li><code>verbosity</code>:  A verbosity parameter for the trade off information / efficiency [def: <code>STD</code>]</li><li><code>cb</code>:         A callback to provide information. [def: <code>trainingInfo</code>]</li></ul><p><strong>Return:</strong></p><ul><li>A named tuple with the following information<ul><li><code>epochs</code>: Number of epochs actually ran</li><li><code>ϵ_epochs</code>: The average error on each epoch (if <code>verbosity &gt; LOW</code>)</li><li><code>θ_epochs</code>: The parameters at each epoch (if <code>verbosity &gt; STD</code>)</li></ul></li></ul><p><strong>Notes:</strong></p><ul><li>Currently supported algorithms:<ul><li><code>SGD</code> (Stochastic) Gradient Descent</li></ul></li><li>Look at the individual optimisation algorithm (<code>?[Name OF THE ALGORITHM]</code>) for info on its parameter, e.g. <a href="Nn.html#Bmlt.Nn.SGD"><code>?SGD</code></a> for the default Stochastic Gradient Descent.</li><li>You can implement your own optimisation algorithm using a subtype of <code>OptimisationAlgorithm</code> and implementing its constructor and the update function <code>singleUpdate(⋅)</code> (type <code>?singleUpdate</code> for details).</li><li>You can implement your own callback function, altought the one provided by default is already pretty generic (its output depends on the <code>verbosity</code> parameter). @see <a href="Nn.html#Bmlt.Nn.trainingInfo-Tuple{Any,Any,Any}"><code>trainingInfo</code></a> for informations on the cb parameters.</li><li>Both the callback function and the <a href="Nn.html#Bmlt.Nn.singleUpdate-Tuple{Any,Any}"><code>singleUpdate</code></a> function of the optimisation algorithm can be used to stop the training algorithm, respectively returning <code>true</code> or returning <code>.stop</code> <code>true</code>.</li><li>The verbosity can be set to any of <code>NONE</code>,<code>LOW</code>,<code>STD</code>,<code>HIGH</code>,<code>FULL</code>.</li><li>The update is done computing the average gradient for each batch and then calling <code>singleUpdate</code> to let the optimisation algorithm perform the parameters update</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L514-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.OptimisationAlgorithm" href="#Bmlt.Nn.OptimisationAlgorithm"><code>Bmlt.Nn.OptimisationAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OptimisationAlgorithm</code></pre><p>Abstract type representing an Optimisation algorithm.</p><p>Currently supported algorithms:</p><ul><li><code>SGD</code> (Stochastic) Gradient Descent</li></ul><p>See <code>?[Name OF THE ALGORITHM]</code> for their details</p><p>You can implement your own optimisation algorithm using a subtype of <code>OptimisationAlgorithm</code> and implementing its constructor and the update function <code>singleUpdate(⋅)</code> (type <code>?singleUpdate</code> for details).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L462-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Bmlt.Nn.trainingInfo-Tuple{Any,Any,Any}" href="#Bmlt.Nn.trainingInfo-Tuple{Any,Any,Any}"><code>Bmlt.Nn.trainingInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><p>trainingInfo(nn,x,y;n,batchSize,epochs,verbosity,nEpoch,nBatch)</p><p>Default callback funtion to display information during training, depending on the verbosity level</p><p><strong>Parameters:</strong></p><ul><li><code>nn</code>: Worker network</li><li><code>x</code>:  Batch input to the network (batchSize,d)</li><li><code>y</code>:  Batch label input (batchSize,d)</li><li><code>n</code>: Size of the full training set</li><li><code>batchSize</code> : size of the specific batch just ran</li><li><code>epochs</code>: Number of epochs defined for the training</li><li><code>verbosity</code>: Verbosity level defined for the training (NONE,LOW,STD,HIGH,FULL)</li><li><code>nEpoch</code>: Counter of the current epoch</li><li><code>nBatch</code>: Counter of the current batch</li></ul><p>#Notes:</p><ul><li>Reporting of the error (loss of the network) is expensive. Use <code>verbosity=NONE</code> for better performances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/Bmlt.jl/blob/df39ad2a78e8ead663bd853448a913627c697fb2/src/Nn.jl#L479-L497">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Perceptron.html">« Perceptron</a><a class="docs-footer-nextpage" href="Clustering.html">Clustering »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 June 2020 08:39">Monday 8 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
